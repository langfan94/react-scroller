import fs from 'fs';
import { resolve, dirname, extname, join } from 'path';
import { createFilter } from '@rollup/pluginutils';
import { transform, minify as minify$1 } from '@swc/core';
import deepmerge from 'deepmerge';
import JoyCon from 'joycon';
import { parse } from 'jsonc-parser';

const joycon = new JoyCon();
joycon.addLoader({
    test: /\.json$/,
    load: async (file)=>{
        const content = await fs.promises.readFile(file, {
            encoding: 'utf-8'
        });
        return parse(content);
    }
});
const getOptions = async (cwd, tsconfig)=>{
    // joycon has its builtin-cache support
    const { data , path  } = await joycon.load([
        tsconfig || 'tsconfig.json',
        'jsconfig.json'
    ], cwd);
    if (path && data) {
        const { importHelpers , esModuleInterop , experimentalDecorators , emitDecoratorMetadata , jsxFactory , jsxFragmentFactory , jsxImportSource , target , baseUrl , paths  } = data.compilerOptions || {};
        return {
            importHelpers,
            esModuleInterop,
            experimentalDecorators,
            emitDecoratorMetadata,
            jsxFactory,
            jsxFragmentFactory,
            jsxImportSource,
            target,
            baseUrl,
            paths
        };
    }
    return {};
};

const INCLUDE_REGEXP = /\.m?[jt]sx?$/;
const EXCLUDE_REGEXP = /node_modules/;
const ACCEPTED_EXTENSIONS = [
    '.ts',
    '.mjs',
    '.js',
    '.tsx',
    '.jsx'
];
const fileExists = (path)=>{
    return fs.promises.access(path, fs.constants.F_OK).then(()=>true
    ).catch(()=>false
    );
};
const resolveFile = async (resolved, index = false)=>{
    for (const ext of ACCEPTED_EXTENSIONS){
        const file = index ? join(resolved, `index${ext}`) : `${resolved}${ext}`;
        // We only check one file at a time, and we can return early
        // eslint-disable-next-line no-await-in-loop
        if (await fileExists(file)) return file;
    }
    return null;
};
function swc(options = {}) {
    const filter = createFilter(options.include || INCLUDE_REGEXP, options.exclude || EXCLUDE_REGEXP);
    return {
        name: 'swc',
        async resolveId (importee, importer) {
            // ignore IDs with null character, these belong to other plugins
            if (importee.startsWith('\0')) {
                return null;
            }
            if (importer && importee[0] === '.') {
                const resolved = resolve(importer ? dirname(importer) : process.cwd(), importee);
                let file = await resolveFile(resolved);
                if (file) return file;
                if (!file && await fileExists(resolved) && (await fs.promises.stat(resolved)).isDirectory()) {
                    file = await resolveFile(resolved, true);
                    if (file) return file;
                }
            }
        },
        async transform (code, id) {
            var ref;
            if (!filter(id)) {
                return null;
            }
            const ext = extname(id);
            if (!ACCEPTED_EXTENSIONS.includes(ext)) return null;
            const isTypeScript = ext === '.ts' || ext === '.tsx';
            const isTsx = ext === '.tsx';
            const isJsx = ext === '.jsx';
            const tsconfigOptions = options.tsconfig === false ? {} : await getOptions(dirname(id), options.tsconfig);
            const swcOptionsFromTsConfig = {
                jsc: {
                    externalHelpers: tsconfigOptions.importHelpers,
                    parser: {
                        syntax: isTypeScript ? 'typescript' : 'ecmascript',
                        tsx: isTypeScript ? isTsx : undefined,
                        jsx: !isTypeScript ? isJsx : undefined,
                        decorators: tsconfigOptions.experimentalDecorators
                    },
                    transform: {
                        decoratorMetadata: tsconfigOptions.emitDecoratorMetadata,
                        react: {
                            pragma: tsconfigOptions.jsxFactory,
                            pragmaFrag: tsconfigOptions.jsxFragmentFactory
                        }
                    },
                    target: (ref = tsconfigOptions.target) === null || ref === void 0 ? void 0 : ref.toLowerCase(),
                    baseUrl: tsconfigOptions.baseUrl,
                    paths: tsconfigOptions.paths
                }
            };
            const swcOption = deepmerge.all([
                swcOptionsFromTsConfig,
                options,
                {
                    jsc: {
                        minify: undefined // Disable minify ob transform, do it on renderChunk
                    },
                    // filename: id,
                    include: undefined,
                    exclude: undefined,
                    tsconfig: undefined,
                    minify: false // Disable minify on transform, do it on renderChunk
                }
            ]);
            /**
       * swc cannot transform module ids with "\0", which is the identifier of rollup virtual module
       *
       * FIXME: This is a temporary workaround, remove when swc fixes it (DO NOT FORGET TO BUMP PEER DEPS VERSION AS WELL!)
       *
       * @see https://rollupjs.org/guide/en/#conventions
       * @see https://github.com/rollup/plugins/blob/02fb349d315f0ffc55970fba5de20e23f8ead881/packages/commonjs/src/helpers.js#L15
       * @see https://github.com/SukkaW/rollup-plugin-swc/pull/1
       * @see https://github.com/swc-project/swc/issues/2853
       */ const { code: transformedCode , ...rest } = await transform(code, swcOption);
            return {
                ...rest,
                code: transformedCode
            };
        },
        renderChunk (code) {
            var ref, ref1, ref2, ref3;
            if (options.minify || ((ref = options.jsc) === null || ref === void 0 ? void 0 : (ref1 = ref.minify) === null || ref1 === void 0 ? void 0 : ref1.mangle) || ((ref2 = options.jsc) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.minify) === null || ref3 === void 0 ? void 0 : ref3.compress)) {
                var ref4;
                return minify$1(code, (ref4 = options.jsc) === null || ref4 === void 0 ? void 0 : ref4.minify);
            }
            return null;
        }
    };
}
function minify(options = {}) {
    return {
        name: 'swc-minify',
        renderChunk (code) {
            return minify$1(code, options);
        }
    };
}
function defineRollupSwcOption(option) {
    return option;
}
function defineRollupSwcMinifyOption(option) {
    return option;
}

export { swc as default, defineRollupSwcMinifyOption, defineRollupSwcOption, minify, swc };
